(()=>{"use strict";const e="nami-wallet",t="extension",n="webpage",o="isWhitelisted",r="enable",s="isEnabled",a="requestData",i="returnData",d={InvalidRequest:{code:-1,info:"Inputs do not conform to this spec or are otherwise invalid."},InternalError:{code:-2,info:"An error occurred during execution of this API call."},Refused:{code:-3,info:"The request was refused due to lack of access - e.g. wallet disconnects."},AccountChange:{code:-4,info:"The account has changed. The dApp should call `wallet.enable()` to reestablish connection to the new account. The wallet should not ask for confirmation as the user was the one who initiated the account change in the first place."}};function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class u{constructor(){c(this,"requestData",(()=>new Promise((async(e,t)=>{this.tabId=await new Promise(((e,t)=>chrome.tabs.getCurrent((t=>e(t.id)))));const n=this;this.port.onMessage.addListener((function t(o){n.port.onMessage.removeListener(t),e(o)})),this.port.postMessage({tabId:await this.tabId,method:a})})))),c(this,"returnData",(async({data:e,error:t})=>{this.port.postMessage({data:e,error:t,method:i,tabId:await this.tabId})})),this.port=chrome.runtime.connect({name:"internal-background-popup-communication"}),this.tabId=new Promise(((e,t)=>chrome.tabs.getCurrent((t=>e(t.id)))))}}class m{constructor(){c(this,"add",((e,t)=>{this._methodList[e]=t})),c(this,"listen",(()=>{chrome.runtime.onMessage.addListener(((e,t,o)=>(e.sender===n&&this._methodList[e.method](e,o),!0)))})),this._methodList={}}}const h={sendToBackground:async function(t){return new Promise(((o,r)=>chrome.runtime.sendMessage({...t,target:e,sender:n},(e=>o(e)))))},sendToContent:function({method:o,data:r}){return new Promise(((s,a)=>{const i=Math.random().toString(36).substr(2,9);window.addEventListener("message",(function n(o){const r=o.data;"object"==typeof r&&null!==r&&r.target&&r.target===e&&r.id&&r.id===i&&r.sender&&r.sender===t&&(window.removeEventListener("message",n),r.error?a(r.error):s(r))})),window.postMessage({method:o,data:r,target:e,sender:n,id:i},window.origin)}))},sendToPopupInternal:function(n,o){return new Promise(((r,s)=>{chrome.runtime.onConnect.addListener((function s(c){c.onMessage.addListener((function u(m){m.tabId===n.id&&(m.method===a&&c.postMessage(o),m.method===i&&r(m),chrome.tabs.onRemoved.addListener((function o(a){n.id===a&&(r({target:e,sender:t,error:d.Refused}),chrome.runtime.onConnect.removeListener(s),c.onMessage.removeListener(u),chrome.tabs.onRemoved.removeListener(o))})))}))}))}))},createInternalController:()=>new u,createProxyController:()=>{chrome.runtime.onMessage.addListener((async n=>{if("object"!=typeof n||null===n||!n.target||n.target!==e||!n.sender||n.sender!==t||!n.event)return;const r=await h.sendToBackground({method:o,origin:window.origin});if(!r||r.error)return;const s=new CustomEvent(`${e}${n.event}`,{detail:n.data});window.dispatchEvent(s)})),window.addEventListener("message",(async function(t){const a=t.data;if("object"!=typeof a||null===a||!a.target||a.target!==e||!a.sender||a.sender!==n)return;if(a.origin=window.origin,a.method===r||a.method===s)return void h.sendToBackground({...a}).then((e=>window.postMessage(e)));const i=await h.sendToBackground({method:o,origin:window.origin});i&&!i.error?await h.sendToBackground(a).then((e=>{window.postMessage(e)})):window.postMessage({...i,id:a.id})}))},createBackgroundController:()=>new m};(function(){const e=document.documentElement.nodeName,t=!e||"html"===e.toLowerCase(),{docType:n}=window.document,o=!n||"html"===n.name;return t&&o})&&((()=>{const e=document.createElement("script");e.async=!1,e.src=chrome.runtime.getURL("injected.bundle.js"),e.onload=function(){this.remove()},(document.head||document.documentElement).appendChild(e)})(),h.createProxyController())})();